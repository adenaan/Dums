<!DOCTYPE html>

<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Domino Game</title>
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #222;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      user-select: none;
      -webkit-user-select: none;
    }

    h1 {
      margin-bottom: 0;
    }

    #roomSection {
      margin-top: 10px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
      max-width: 420px;
    }

    #roomSection input {
      flex: 1 1 45%;
      padding: 12px;
      font-size: 16px;
      border-radius: 8px;
      border: none;
      outline: none;
    }

    #roomSection button {
      flex: 1 1 100%;
      background: #4caf50;
      color: white;
      font-size: 18px;
      border: none;
      border-radius: 8px;
      padding: 12px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    #roomSection button:hover {
      background: #45a049;
    }

    #gameStatus {
      margin-top: 15px;
      font-weight: 600;
      font-size: 18px;
      min-height: 24px;
      text-align: center;
      max-width: 420px;
    }

    #board, #hand {
      margin-top: 20px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 420px;
      gap: 8px;
      min-height: 90px;
    }

    .tile {
      background: white;
      color: black;
      border-radius: 10px;
      width: 52px;
      height: 85px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-size: 22px;
      font-weight: bold;
      user-select: none;
      cursor: pointer;
      border: 2px solid transparent;
      transition: border-color 0.2s ease;
      white-space: pre-line;
    }

    .tile.highlight {
      border-color: yellow;
      cursor: pointer;
    }

    .tile.disabled {
      cursor: default;
      opacity: 0.5;
    }

    #hand {
      margin-bottom: 40px;
    }

    /* Modal styling */
    .modal {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.75);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
      user-select: none;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: #333;
      padding: 30px 40px;
      border-radius: 12px;
      text-align: center;
      color: white;
      max-width: 320px;
      box-shadow: 0 0 15px 5px rgba(255, 255, 0, 0.7);
    }

    .modal-content h2 {
      margin: 0 0 20px;
      font-size: 26px;
    }

    .modal-content button {
      background: #4caf50;
      color: white;
      border: none;
      padding: 12px 28px;
      font-size: 18px;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    .modal-content button:hover {
      background: #45a049;
    }

    /* Toggle switch container */
    .toggle-switch {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      color: white;
      user-select: none;
      cursor: pointer;
      flex: 1 1 100%;
      max-width: 150px;
      margin-top: 6px;
    }

    /* Hide default checkbox */
    .toggle-switch input[type="checkbox"] {
      opacity: 0;
      width: 0;
      height: 0;
      position: absolute;
    }

    /* The slider */
    .slider {
      position: relative;
      width: 36px;
      height: 18px;
      background-color: #555;
      border-radius: 18px;
      transition: background-color 0.3s;
      flex-shrink: 0;
    }

    /* The circle inside slider */
    .slider::before {
      content: "";
      position: absolute;
      width: 14px;
      height: 14px;
      left: 2px;
      top: 2px;
      background-color: white;
      border-radius: 50%;
      transition: transform 0.3s;
    }

    /* Checked state */
    .toggle-switch input:checked + .slider {
      background-color: #4caf50;
    }

    .toggle-switch input:checked + .slider::before {
      transform: translateX(18px);
    }

    /* Optional label text styling */
    .label-text {
      user-select: none;
      white-space: nowrap;
    }

    /* Responsive tweaks */
    @media (max-width: 480px) {
      .toggle-switch {
        font-size: 12px;
        max-width: 140px;
        gap: 6px;
      }

      .slider {
        width: 30px;
        height: 16px;
      }

      .slider::before {
        width: 12px;
        height: 12px;
        top: 2px;
        left: 2px;
      }

      .toggle-switch input:checked + .slider::before {
        transform: translateX(14px);
      }
    }

    /* Voice Chat Button Styling */
    #voiceChatControls {
      margin-top: 10px;
      display: flex;
      justify-content: center;
      gap: 10px;
      width: 100%;
      max-width: 420px;
      flex-wrap: wrap;
    }

    #muteAudioToggle {
      flex: 1 1 150px;
    }
  </style>
</head>
<body>
  <h1>Domino Game</h1>
  <div id="roomSection">
    <input id="playerName" placeholder="Your Name" autocomplete="off" />

    <!-- Remember Name Toggle -->
    <label class="toggle-switch" title="Remember Name">
      <input type="checkbox" id="rememberNameToggle" />
      <span class="slider"></span>
      <span class="label-text">Remember Name</span>
    </label>

    <input id="roomCode" placeholder="Room Code" autocomplete="off" />
    <button onclick="joinRoom()">Join Room</button>
  </div>

  <div id="voiceChatControls" style="display:none;">
    <label class="toggle-switch" title="Mute Microphone">
      <input type="checkbox" id="muteAudioToggle" />
      <span class="slider"></span>
      <span class="label-text">Mute Microphone</span>
    </label>
  </div>

  <div id="gameStatus"></div>
  <div id="board"></div>
  <h3>Your Hand</h3>
  <div id="hand"></div>

  <!-- Game Over Modal -->
  <div id="gameOverModal" class="modal">
    <div class="modal-content">
      <h2 id="winnerText">Player X won!</h2>
      <button id="restartBtn">Restart Game</button>
    </div>
  </div>

  <!-- Blocked Modal -->
  <div id="blockedModal" class="modal">
    <div class="modal-content">
      <h2 id="blockedText">You are blocked!</h2>
      <button id="blockedCloseBtn">OK</button>
    </div>
  </div>

  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

  <script>
    // === Existing Domino Game code ===
    const socket = io("https://dominoesgame.glitch.me");
    let currentRoom = "";
    let myTiles = [];
    let myId = "";
    let currentTurn = "";
    let board = [];
    let players = [];
    let playerNames = {};

    const gameStatusEl = document.getElementById("gameStatus");
    const boardEl = document.getElementById("board");
    const handEl = document.getElementById("hand");

    const gameOverModal = document.getElementById("gameOverModal");
    const winnerText = document.getElementById("winnerText");
    const restartBtn = document.getElementById("restartBtn");

    const blockedModal = document.getElementById("blockedModal");
    const blockedText = document.getElementById("blockedText");
    const blockedCloseBtn = document.getElementById("blockedCloseBtn");

    const playerNameInput = document.getElementById("playerName");
    const rememberToggle = document.getElementById("rememberNameToggle");

    restartBtn.onclick = () => {
      location.reload();
    };

    blockedCloseBtn.onclick = () => {
      blockedModal.classList.remove("active");
    };

    function joinRoom() {
      const code = document.getElementById("roomCode").value.trim();
      const name = playerNameInput.value.trim() || "Player";
      if (!code) {
        alert("Please enter a room code.");
        return;
      }
      currentRoom = code;
      socket.emit("join-room", { roomCode: code, playerName: name });
      gameStatusEl.textContent = "Waiting for players...";
    }

    socket.on("connect", () => {
      myId = socket.id;
    });

    socket.on("room-full", () => {
      alert("Room is full! Please try another room.");
    });

    socket.on("player-joined", ({ players: p, names }) => {
      players = p;
      playerNames = names;
      updateStatus();
    });

    socket.on("start-game", (data) => {
      board = data.board || [];
      myTiles = data.players[socket.id] || [];
      currentTurn = data.currentTurn;
      renderBoard();
      renderHand();
      updateStatus();
      showVoiceChatControls(true);
    });

    socket.on("update-game", (data) => {
      board = data.board || [];
      myTiles = data.players[socket.id] || [];
      currentTurn = data.currentTurn;
      renderBoard();
      renderHand();
      updateStatus();
    });

    socket.on("game-over", (winnerId) => {
      winnerText.textContent = playerNames[winnerId] + " won!";
      gameOverModal.classList.add("active");
    });

    socket.on("blocked", (msg) => {
      blockedText.textContent = msg || "You are blocked!";
      blockedModal.classList.add("active");
    });

    function renderBoard() {
      boardEl.innerHTML = "";
      if (board.length === 0) {
        boardEl.textContent = "Board is empty";
        return;
      }
      board.forEach(tile => {
        const tileEl = createTileElement(tile);
        boardEl.appendChild(tileEl);
      });
    }

    function renderHand() {
      handEl.innerHTML = "";
      myTiles.forEach(tile => {
        const tileEl = createTileElement(tile);
        tileEl.classList.add("highlight");
        tileEl.onclick = () => playTile(tile);
        handEl.appendChild(tileEl);
      });
    }

    function createTileElement(tile) {
      const tileEl = document.createElement("div");
      tileEl.className = "tile";
      tileEl.textContent = tile.left + "\n" + tile.right;
      return tileEl;
    }

    function playTile(tile) {
      if (socket.id !== currentTurn) {
        alert("Not your turn!");
        return;
      }
      socket.emit("play-tile", tile);
    }

    function updateStatus() {
      if (players.length === 0) {
        gameStatusEl.textContent = "No players in room.";
        return;
      }
      if (currentTurn) {
        gameStatusEl.textContent = `Current turn: ${playerNames[currentTurn] || currentTurn}`;
      } else {
        gameStatusEl.textContent = "Waiting for game to start...";
      }
    }

    // Remember Name toggle logic
    rememberToggle.addEventListener("change", () => {
      if (rememberToggle.checked) {
        localStorage.setItem("dominoPlayerName", playerNameInput.value);
      } else {
        localStorage.removeItem("dominoPlayerName");
      }
    });

    playerNameInput.addEventListener("input", () => {
      if (rememberToggle.checked) {
        localStorage.setItem("dominoPlayerName", playerNameInput.value);
      }
    });

    // Load remembered name on page load
    window.addEventListener("load", () => {
      const savedName = localStorage.getItem("dominoPlayerName");
      if (savedName) {
        playerNameInput.value = savedName;
        rememberToggle.checked = true;
      }
    });

    // === Voice Chat Code Starts Here ===

    // Elements
    const muteAudioToggle = document.getElementById("muteAudioToggle");
    const voiceChatControls = document.getElementById("voiceChatControls");

    // Show/hide voice chat controls
    function showVoiceChatControls(show) {
      voiceChatControls.style.display = show ? "flex" : "none";
    }

    // Peer connections and streams
    const peers = {};
    const localStreamPromise = navigator.mediaDevices.getUserMedia({ audio: true }).catch(() => null);
    let localStream = null;
    let isMuted = false;

    // WebRTC configuration - use public STUN servers
    const rtcConfig = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" }
      ]
    };

    // Initialize local audio stream
    async function initLocalStream() {
      localStream = await localStreamPromise;
      if (!localStream) {
        console.warn("Microphone access denied or unavailable.");
        muteAudioToggle.disabled = true;
        return;
      }
      setLocalAudioMute(isMuted);
    }

    // Set local audio track mute/unmute
    function setLocalAudioMute(mute) {
      if (!localStream) return;
      localStream.getAudioTracks().forEach(track => {
        track.enabled = !mute;
      });
    }

    // Handle mute toggle change
    muteAudioToggle.addEventListener("change", () => {
      isMuted = muteAudioToggle.checked;
      setLocalAudioMute(isMuted);
    });

    // Socket signaling for voice chat
    socket.on("connect", () => {
      initLocalStream();
    });

    // When a new peer joins, signaling to start WebRTC
    socket.on("voice-offer", async ({ fromId, sdp }) => {
      if (fromId === socket.id) return; // ignore self

      console.log("Received voice offer from", fromId);

      const peerConnection = createPeerConnection(fromId);

      try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(sdp));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);

        socket.emit("voice-answer", { toId: fromId, sdp: peerConnection.localDescription });
      } catch (err) {
        console.error("Error handling voice offer:", err);
      }
    });

    socket.on("voice-answer", async ({ fromId, sdp }) => {
      if (fromId === socket.id) return;

      console.log("Received voice answer from", fromId);

      const peerConnection = peers[fromId];
      if (!peerConnection) return;

      try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(sdp));
      } catch (err) {
        console.error("Error setting remote description for answer:", err);
      }
    });

    socket.on("voice-ice-candidate", ({ fromId, candidate }) => {
      if (fromId === socket.id) return;

      const peerConnection = peers[fromId];
      if (!peerConnection) return;

      if (candidate) {
        peerConnection.addIceCandidate(new RTCIceCandidate(candidate)).catch(e => {
          console.error("Error adding received ICE candidate", e);
        });
      }
    });

    socket.on("voice-peer-left", (peerId) => {
      console.log("Peer left voice chat:", peerId);
      closePeerConnection(peerId);
    });

    // When joining room, initiate voice call offers to all existing peers
    socket.on("existing-players", (existingPlayerIds) => {
      existingPlayerIds.forEach(peerId => {
        if (peerId !== socket.id) {
          initiateCall(peerId);
        }
      });
    });

    // Create RTCPeerConnection and add local stream
    function createPeerConnection(peerId) {
      if (peers[peerId]) {
        return peers[peerId];
      }

      const pc = new RTCPeerConnection(rtcConfig);
      peers[peerId] = pc;

      // Add local stream tracks
      if (localStream) {
        localStream.getTracks().forEach(track => {
          pc.addTrack(track, localStream);
        });
      }

      pc.onicecandidate = event => {
        if (event.candidate) {
          socket.emit("voice-ice-candidate", {
            toId: peerId,
            candidate: event.candidate,
          });
        }
      };

      pc.ontrack = event => {
        // Play the remote audio stream
        playRemoteStream(peerId, event.streams[0]);
      };

      pc.onconnectionstatechange = () => {
        if (pc.connectionState === "disconnected" || pc.connectionState === "failed" || pc.connectionState === "closed") {
          closePeerConnection(peerId);
        }
      };

      return pc;
    }

    // Initiate call: create offer and send to peer
    async function initiateCall(peerId) {
      const pc = createPeerConnection(peerId);

      try {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        socket.emit("voice-offer", {
          toId: peerId,
          sdp: pc.localDescription,
        });
      } catch (err) {
        console.error("Error initiating call:", err);
      }
    }

    // Play remote audio stream in hidden audio element
    const remoteAudioElements = {};
    function playRemoteStream(peerId, stream) {
      let audio = remoteAudioElements[peerId];
      if (!audio) {
        audio = new Audio();
        audio.autoplay = true;
        audio.controls = false;
        audio.style.display = "none";
        document.body.appendChild(audio);
        remoteAudioElements[peerId] = audio;
      }
      audio.srcObject = stream;
      audio.play().catch(e => console.warn("Audio play error:", e));
    }

    // Close and cleanup peer connection and audio
    function closePeerConnection(peerId) {
      if (peers[peerId]) {
        peers[peerId].close();
        delete peers[peerId];
      }
      if (remoteAudioElements[peerId]) {
        remoteAudioElements[peerId].pause();
        remoteAudioElements[peerId].srcObject = null;
        document.body.removeChild(remoteAudioElements[peerId]);
        delete remoteAudioElements[peerId];
      }
    }

    // When joining a room, ask server for existing players to initiate voice calls
    socket.on("room-joined", (data) => {
      if (!data) return;
      const existing = data.existingPlayerIds || [];
      socket.emit("request-existing-players");
      showVoiceChatControls(true);
    });

    // When the page unloads, close all peer connections
    window.addEventListener("beforeunload", () => {
      Object.keys(peers).forEach(closePeerConnection);
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
    });

  </script>
</body>
</html>
